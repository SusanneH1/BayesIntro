---
title: "Git, GitHub & R"
subtitle: "A Students Primer"
format: html
---

# Preface

...

# Prerequisites

- [x] [R](https://cloud.r-project.org) installed
- [x] [RStudio](https://posit.co/products/open-source/rstudio/) installed
- [x] [Git](https://git-scm.com/downloads) installed
- [x] [GitHub](https://github.com) account created

# Hello `R`

## R code

`R` is an interpreted high-level programming language tailored to statistical computing. *High level* means that in order to get `R` going, we users don't really need to know anything about the computer architecture and machine code. `R` code abstracts from machine code, which is the only language your computer understands and executes. Instead, `R` code is much more readable and easier to write because it uses elements of natural language and programming concepts (e.g., loops and functions), data structures (e.g., data frames), and expressions (arithmetic, true/false) that are familiar or easy to learn. Because `R` code is not machine code, an *interpreter* reads your `R` code and translates each code line into machine code, hence an interpreted language. How this translation technically works, must not be your business. The only thing you need to learn is how to write some R code. R code is then essentially a set of written commands, that is read and executed by a command line interpreter. To write `R` code and access the interpreter, we use the `R` *console* as a command line interface:

![](git_primer_files/R-console.PNG){fig-align="center" width="506"}

In the console you can write code (e.g., `1+1`) and executed by pressing `enter`. Below the code, `R` returns the output.

## R Studio

One shortcoming of the console is that it does not save the code after the session ends. This is of course a problem, since we often work on an analysis project for days or even weeks or months and don't want to and can't start from scratch every time. The easy solution here is to write the code into a text file that can be saved and accessed whenever we want to. Text files that (only) entail code are generally referred to as a *script* and we can write such a script with `R` code by using the file extension '.R', rather than, e.g., '.docx' or '.text'.

Another shortcoming of the console is that it looks kind of old and boring and doesn't allow for much more than just writing the code.
Thus, for our daily use, we will not directly write in the console but rely on RStudio. 
RStudio is an *integrated development environment* (IDE) that provides a powerful and user-friendly interface for working with R.

![](git_primer_files/RStudio.PNG){fig-align="center" width="506"}

RStudio is designed to improve the efficiency and ease of use of the R programming language, by providing a range of tools and features that streamline the coding and analysis process.
One of the features is that it offers you more than one panel, through which you can access different types of information. 
E.g., in the screenshot above, the upper left panel entails a R script, in which we can write our code. 
Below, you see the familiar R console which remains the processing engine. 
One big advantage of working with scripts in RStudio is that you can directly execute code from the script in the console by using the key combination `ctrl` + `enter` (Windows) or `cmd` + `enter` (Mac).
You can store this script as any other file on your computer, ready to be executed at any time you want. 
Some other advantages of using RStudio over using only the R Console include:

- Enhanced code editing: RStudio provides a range of code editing features such as syntax highlighting, code completion, and error checking that make it easier to write and debug R code.

- Integrated documentation: RStudio provides easy access to R's extensive documentation, making it easier to learn and use the language effectively.

- Workspace management: RStudio provides a range of tools for managing R workspaces, including the ability to view, load, and save data, and to manage R packages.

- Integrated debugging: RStudio provides powerful debugging tools that help to identify and resolve errors in R code, including the ability to step through code line-by-line and to set breakpoints.

- Integration with version control systems: RStudio integrates with popular version control systems such as Git, making it easier to manage and collaborate on R projects.

You will learn about these features and how to use them throughout this course. 
The important take away for now is just that everything that can be done by only using the console can be done in RStudio too, but better.
Therefore, from now we only access the console and write code in RStudio. 

## Basics in R

Now that we've set up `R` and `RStudio`, we want to learn the basics of programming in `R`. 
Many of the commands, functions, and concepts we need throughout this course will be learned on the fly once we need them. 
Here, we only look at the most essential points, which are outlined in chapter 2 of the open access book [Hands-On Programming with R](https://rstudio-education.github.io/hopr/).

### Arithmetic Expressions 

Arithmetic expressions or operations are mathematical operations performed on numerical data such as addition (`+`), subtraction (`-`) , multiplication (`*`) or division (`/`).   
You write these expressions as on paper using the above symbols. 

```{r}
1+1 # addition
2-2 # subtraction
3*3 # multiplication
4/4 # division
```
### Objects

`R` is am object oriented language because it allows to create and manipulate objects using arithmetic expressions and all sorts of function that you will learn about.
Objects can be thought of as data storage, which we can assign names to.
Specifically, objects entail data that is structured in some way. 
We distinguish between different object types depending on what the data looks like and how it is structured.
However, irrespective of the object type, we can name it however we want. 
We now look at object types we will frequently encounter: 

#### Scalars 

Scalars are single values such as a number, a character (letter), a character string (word), or logical values (TRUE or FALSE).
We assign names to scalars and objects in general using the operator `<-` (Shortcuts: `Alt` + `-`on Windows; `Option` + `-` on Mac).

```{r}
scalar_1 <- 1 # numeric

scalar_2 <- "a" # character

scalar_3 <- "word" # word

scalar_4 <- TRUE # logical/Boolean
```

We can access (look into) the object by simply typing its name.

```{r}
scalar_1
```

Having created the object, we can manipulate it just as it was a value: 

```{r}
scalar_1 + 1 # addition
scalar_1 * 10 # multiplication
```
We can also create new objects from existing objects either by copying the existing object into an object of a different name or by manipulating the existing object and assigning the output of the operation a name.

```{r}
scalar_5 <- scalar_1 # copying
scalar_5
scalar_6 <- scalar_1 * 10 # new object
scalar_6
```

Occasionally, we will ask R to execute code that is actually not a valid operation.
E.g., we can only multiple numerical values, but not letters. 
In these cases, R will return an error message. 

```{r}
scalar_2
```

```{r eval=FALSE}
scalar_2 * 4
```

<span style="color:red;">Error in scalar_2 * 4 : non-numeric argument to binary operator</span>

The command `scalar_2 * 4` returns an error. 
This is because the object `scalar_2` is the character `a` which cannot be multiplied. 

#### Vectors

Vectors are among the most common objects data structures we will encounter in R.
Vectors are ordered collection of values of the same data type. 
We can create a vector object using the familiar `<-` and the `c()` command. 

```{r}
x <- c(1, 2, 3, 4) 
x
```
One of the prime features of R is that it is a "vectorized" language. 
This means that you can perform the same operation on an entire vector of values at once.
As with scalars, you can store the output of vectorized operations in a new object. 

```{r}
y <- x*2
y
```
One powerful feature we have to take care of when working with vectors is that computations consider the position of elements (values) in a vector.
That is, operations between vectors are performed such that the operation applies to elements at the same position in the vectors.
Consider the output of multiplication of the two vectors `x = `r x`` and `y = `r y``. 
Here, the first element of `x` is multiplied with the first element of `y` and so on. 

```{r}
x*y
```
Importantly, if the vectors have unequal lengths, the shorter vector is first repeated until it is as long as the longer vector, and then the operations are performed element wise.
In the following, the vector `z` is repeated once such that it has the same length as `x`.

```{r}
z <- c(1,2) 
x*z
```
If we think of scalars as vectors of length 1, we can now better understand the previous operation `x*2`. 
I.e., `2` is repeated 4 times. 

```{r}
a <- 2 
x*a
```
Above, we only considered numerical vectors. 
However, as scalars, vectors can be of different type

```{r}
vector_1 <- c(1,2,3) # numeric
vector_1
vector_2 <- c("a", "b", "c") # character
vector_2
vector_3 <- c(TRUE, FALSE, TRUE) # logical
vector_3
```
#### Data Frames

Being a set of values, vectors are ideally suited to represent variables (columns) in a data frame.
Data frames are a data structure we will encounter very often.
According to Hadley Wickham, tidy data frames all look alike and follow this set of rules:

1. Each variable must have its own column.
2. Each observation must have its own row.
3. Each value must have its own cell.

To illustrate, consider the following code example, where we use the three vectors (variables) `Var_1`, `Var_2`, and `Var_3` and the function `data.frame()` to build data set. 

```{r}
ID <- c("A", "B", "C")
Var_1 <- c(1, 2, 3)
Var_2 <- c(2, 4, 6)
Var_3 <- c(4, 8, 12)
dat <- data.frame(Var_1, Var_2, Var_3)
dat
```

Of course, not all data sets outside of this course will look like this from the start, but there is a good reason to bring the data into this format before you start analyzing it.
One advantage becomes immediately clear: The row number indicates the position within a variable vector (column).
We can now make perfect use of the vectorized nature of R by applying the same operation on a variable to all rows at once. 
As data frames are one of the most common data structures, we need to learn a set of commands (functions) that help us to manipulate them and obtain the information we want. 
In the following, we will briefly go over some basic commands. 
Later we will introduce a number of functions from the `tidyverse` that make writing code and working with data frames particularly easy, even if the manipulations become more complex.

As with vectors, we can apply the same operation to an entire data frame. 

```{r}
dat*2
```

How does it work under the hood?
R represents all cell entries in a vector, starting from the left and traversing the columns one by one from top to bottom.
Rarely, this is what we need.
Usually we only want to apply operation to specific columns or cells in a data frame.
There are multiple ways to obtain a variable vector out of a data set. 

```{r}
dat$Var_1 # dollar notation
dat[, 1] # matrix notation with column number
dat[, "Var_1"] # matrix notation with column name
```
In the matrix notation, values before the comma represent the row and values after the comma represent the column. 
The matrix notation has the advantage that we can refer to columns by both the column number and the variable name. 
Another advantage is that we can also obtain multiple columns or specific cell entries.

```{r}
dat[, c(1,2)] # Variable/column 1 and 2
dat[1,1] # cell entry in row 1, column 2 
```
Knowing how to retrieve certain values from a data frame, we can now apply operations on them as before. 
The principles of vectorized operations remain the same. 

```{r}
dat[, 1]
dat[, 1] * 2
x <- c(1,2,3)
dat[, 1] * x 
dat$Var_1 * x
```

Importantly, the above code doesn't store the outputs in the data frame: 

```{r}
dat[,1]
```
To do so, we have to use the `<-` operator again and point it to the position in the data frame, we want it to be stored. 
If we operate on an entire column, we can either override an existing column (usually the one we operated on) or add a new column, depending on what our goal is: 

```{r}
# overriding
dat[, 1] <- dat[, 1] * x 
dat
dat$Var_2 <- dat$Var_2 * x
dat

# adding
dat[, 4] <- dat[, 3] * x 
dat
dat$Var_5 <- dat[, 4] * x
dat
```

#### Functions

Simple arithmetic operations are by no means the only possible operations in R. 
Moreover, multiple operations can be combined to longer or more complicated computation sequence. 
Irrespective of the exact operation, the more often we rely on it, we should write a function for this operation instead of copy and pasting the code multiple times in order to apply it to different data.
Because many operations are fairly common and useful to different projects, others might have already written a function for that operation. 
Some might come with the initial R installation such as `data.frame()` and others are obtained by installing a so-called package that is distributed and freely available online.
In the following, we briefly explain what a function is and how we work with them and then we install for demonstrative and later purposes a package that has multiple helpful functions for working with data frames and doing data analysis more generally.


A function generally consists of three parts: 

1. A function name.
2. Objects and other arguments that are the inputs to the function.
3. The code body `{}` that specifies the code and turns inputs into outputs. 

To illustrate, consider the following code for a function `summing` that sums up all values in a vector `x`:

```{r}
summing <- # function name
  function(x){ # inputs 
    
    # body 
    total <- 0
    for (i in 1:length(x)) {
    total <- total + x[i]
  }
  return(total)
    
}
```
At this point, we don't have to understand the whole code.
The important take away is that we have now created a function `summing()` that can sum up all values within a numeric vector. 
Therefore, we just write the name of the function and place the vector in the bracket.
The main idea is that the function takes the vector and puts it in the place of the `x` in the above code while executing it. 

```{r}
x <- c(1,2,3)
summing(x)
summing(dat$Var_1)
```
Of course, summing vectors is fairly common operation and there is already a function in place for it: 

```{r}
sum(x)
sum(dat$Var_1)
```
Thus, before repeatedly writing endless lines of code or racking your brains, search online whether there is already a function that does what you want.
In some cases, you are required to install a new package that entails this function. 

One last thing about R code and functions: 
You can combine multiple functions by placing one into the other. 
The way it works is by reading R code from the inside to the outside.
Ultimately, a function returns an output. 
The output of the inner (or enclosed function) is then used as input of the outer function. To illustrate consider the following code that combines the `sum()` function and the `abs()` function that returns the non-negative absolute value.
First, we do the operation one by one by saving the output of `sum()` in a new object that is then the input to `abs`.
Thereafter, we do it all at once. 

```{r}
x <- c(-1, -2, -3)
sum_x <- sum(x)
sum_x
abs(sum_x)
abs(sum(x))
```
#### Packages

R packages may entail functions, data, and documentation that are not provided with the standard installation of R. 
R packages are created and maintained by a community of developers and users who share their work with others. 
These packages can be downloaded from the internet and installed in R using the install.packages() function. Once installed, the functions and data in the package can be loaded into R using the library() function, making them available for use in your code.

There are thousands of R packages available for a wide range of tasks, from data manipulation and visualization to statistical modeling and machine learning. Using packages can save R users a lot of time and effort by providing pre-written code and functions for common tasks, allowing them to focus on their specific research questions or analysis goals.

In the following, we will install the `tidyverse` package, which itself is a collection of other packages. 

```{r eval = FALSE}
install.packages("tidyverse")
library("tidyverse")
```

Now that we have learned the basics of `R`, we will continue with learning about Git and GitHub. 

# Hello `Git`

- Check if Git is already installed. 
- Open a shell/terminal on your machine and type:

``` bash
git --version
```

- If the command returns something along the lines `git version ...`, you are fine. 
If the command returns `git: command not found`, Git is not installed yet. 
Install Git from the [browser](https://git-scm.com/downloads) and repeat the above procedure.

- Introduce yourself to Git with a user name and the E-mail address you (will) use for the GitHub account.

``` bash
git config --global user.name 'YOUR USERNAME'
git config --global user.email 'YOUR EMAIL ADDRESS'
```

-   Check if everything works:

``` bash
git config --global --list
```

- Somewhere in the output, you should find a line that entails your username and a line that entails the e-mail address. 
- Restart your machine.

# Hello GitHub

- If not done yet, go to [GitHub](https://github.com) and create an account with the E-Mail address you introduced to Git before.

## Personal Access Token

- To allow Git to communicate with GitHub via the HTTPS protocol, we need to generate and store a [personal access token (PAT)](https://github.com/settings/tokens)
- Use the following R shortcut that comes with a pre-selected scope.

```{r eval = F}
install.packages("usethis")
usethis::create_github_token()
```

- Give the PAT a clear name (e.g., my-private-machine), "Generate token", copy the PAT to the clipboard and paste it somewhere for short term storage (also, don't close the window yet).
- Run the following lines of code to store the PAT by pasting it into the console:

```{r eval = F}
install.packages("gitcreds")
gitcreds::gitcreds_set()
```

## Create and Clone a Repository

- Go to GitHub and create a [new repository](https://github.com/new).
- Add a description and click "Add README file".
- Create a repository.
- Clone the repository to your computer via the green "\<\> Code" button. Click "HTTPS" and copy the address.
- Go to R and open a new project with version control (Copy the remote address). 

## GitHub Fundamentals

### Commit, Push, Pull

-   In the following, you want to exercise some commands fundamental to the work with `Git`: `pull`, `push`, `commit`.

-   `commit` allows you to save the latest changes in your repository (e.g., if you added some new lines of code)

-   `pull` and `push` sync the local repository on your machine and the remote repository on GitHub. With `pull` you sync changes that were first made in the remote repository; with `push`, you snyc changes made in the local repository.

-   It is a good practice to first pull from the remote repository before you push back to GitHub. To practice, do some changes on GitHub, commit, and pull them to the local repository. Then do some changes in the local repository, commit, and push them. Repeat to gain some practice.

## Branching

-   With `Git`, you can create branches besides the main branch. Such feature branches allow you to let the main branch as it is and test new things on them. Later, you can merge changes on the feature branch into the main branch.

-   You create a branch from the terminal with `bash git branch "branch-name"` and then checkout to the branch with `bash git checkout "branch-name"`.

-   Once you have done some work on the feature branch and commited it, you can checkout to the main branch again and merge the changes.

``` bash
git checkout main
git merge branch-name
```

## Pull requests. 

[...]


# Resources

[Happy Git](Happy%20Git%20and%20GitHub%20for%20the%20useR)
