---
title: "Git, GitHub & R"
subtitle: "A Students Primer"
format: html
---

# Prerequisites

-   [x] [R](https://cloud.r-project.org) installed
-   [x] [RStudio](https://posit.co/products/open-source/rstudio/) installed
-   [x] [Git](https://git-scm.com/downloads) installed
-   [x] [GitHub](https://github.com) account created

# Hello `R`

## What is R code and how does it work?

`R` is an *interpreted high-level* programming language specifically tailored to statistical computing. In fact, `R` can do more than statistical computing, but that's what it was designed for, that's what it's good at, and that's what we're primarily concerned with in this course.

*High level* refers to the fact that we as `R` users aren't required to know anything at all about the computers architecture and machine code. This doesn't mean that machine code isn't important. Machine code is the only language that your computer understands and executes. However, machine code is hard to write and understand and not a desirable to tool to actively work with in data analysis projects. `R` code makes our lives much easier: It is much more readable and straightforward to write because it relies on elements of natural language and programming concepts such as loops and functions, data structures like data frames, and expressions including arithmetic and true/false statements, which are either familiar and relatively easy to learn.

Because `R` code is not machine code and this is what is ultimately required to get your machine and code running, `R` code needs to be interpreted and translated to machine code. This is what a so-called *interpreter* does and this is what makes `R` an *interpreted* language. If you are just concerned with data analysis, it's not necessary to understand the technical aspects of this translation process. What you need to learn and practice is how write some `R` code.

`R` code consists of written commands that are read executed by a command-line interpreter. To access the interpreter and write `R` code, we take a brief look into the *console*, `R`'s command-line interface.

![](git_primer_files/R-console.PNG){fig-align="center"}

In the console you can write code (e.g., `1+1`) and execute it by pressing `Enter`. Below the code, `R` returns the so-called *output* (i.e., `2`). Every line of code needs to end up in the console in order to be executed and obtain its output.

## Giving R a better look with RStudio

The console has some shortcomings. For one, the console doesn't secure your code once you close it. Since data analysis projects can take days, months or even years, this is a problem: You won't and can't start from scratch every time. The simple solution is to write your code in a text file that can be saved on your machine. Text files that only contain code are referred to as *scripts* and usually have a file extension that indicates the language in which the code is written. `R` scripts have the extension '.R'.

Another shortcoming of the console is that it looks old and doesn't allow for much more than just writing code. However, throughout this course you'll realize that a proper data analysis workflow requires much more than just writing code. Thus, we'll not directly work in console but rely on *RStudio*. RStudio is an *integrated development environment* (IDE) that provides a powerful and user-friendly graphical interface for working with R.

![](git_primer_files/RStudio.PNG){fig-align="center"}

RStudio is designed to ease the use of `R` and improve your efficiency by offering a range of tools and features that streamline data management, coding and analysis. 

One feature of RStudio is that it has more than one panel.
Each panel provides access to different types of information. 
E.g., the upper left panel in the above screenshot entails a script `script.R`, in which we can write and secure the code we previously entered in the console. 
In the panel below, you see this console again. 
Remember that the console remains the processing engine and that every line of code must be passed through it in order to be executed. 
However, you don't have to copy-and-paste your code from the script to the console. 
Instead, you can directly execute code from the script in the console by pressing the key combination `ctrl` + `enter` in Windows or `cmd` + `enter` in macOS. 
You can store this script like any other file on your computer, ready to be executed at any time you want.

You'll learn about the other panels throughout the course on the fly.
At this point, let's just briefly consider other advantages of working in RStudio instead of just in the console.

-   Enhanced code editing: RStudio provides a range of code editing features such as syntax highlighting, code completion, and error checking that make it easier to write and debug R code.

-   Integrated documentation: RStudio provides easy access to R's extensive documentation, making it easier to learn and use the language effectively.

-   Workspace management: RStudio provides a range of tools for managing R workspaces, including the ability to view, load, and save data, and to manage R packages.

-   Integrated debugging: RStudio provides powerful debugging tools that help to identify and resolve errors in R code, including the ability to step through code line-by-line and to set breakpoints.

-   Integration with version control systems: RStudio integrates with popular version control systems such as Git, making it easier to manage and collaborate on R projects.

You'll learn about these features and how to integrate them in your workflow throughout this course. 
The important takeaway for now is that everything that can be done using only the console can be done in RStudio too, but better.
Thus, from now on, we will only access the console via RStudio.

## Learning the R basics

Now that we've set up `R` and committed ourselves to using RStudio, we want to learn the basics of programming in `R`.
Many important commands, functions, and concepts that we need throughout the course will be introduced as we actually need them.
At this point, we will focus only on the most essential points to give you an idea of how R works and what it feels like to create and manipulate some simple data structures. 

### Arithmetic Expressions

*Arithmetic expressions* trigger mathematical operations on numerical data.
In `R`, these expressions follow the same order of operations as in standard mathematics, even if some of the mathematical *operators* may look a bit different from the ones on paper or in the calculator.

```{r}
1+1 # addition
1-1 # subtraction
1*1 # multiplication
1/1 # division

# expressions where order of operations matter
1+1/2 #  division prior addition
(1+1)/2 # brackets prior the rest
```

### Objects

`R` is a *object-oriented* language because we use arithmetic expressions and all kinds of other functions to create and manipulate *objects*. 
Objects can be thought of as data storage, which we assign names to. 
More specifically, objects usually entail data that is structured in some way. 
Based on what exactly this data is and how it is structured, we refer to the object as a certain type. 
(However, irrespective of the *object type*, we can give objects whatever name we want.) 
We now look at different object types we will often encounter:

#### Scalars

Scalars are fundamental objects that represent individual values.
They can take on different data types, such as numerical, character, string, or logical.

- Numerical scalars are used to represent numeric values, such as integers or decimal numbers.

- Character scalars are used to represent individual characters, such as letters, digits, or punctuation marks. 

- String scalars, on the other hand, are used to represent a sequence of characters, often in the form of a word or a phrase.

- Logical scalars are used to represent logical values, such as TRUE or FALSE, which are commonly used for conditional expressions or comparisons.

Overall, scalars are simple but essential components of R programming that allow us to manipulate individual values and perform basic arithmetic and logical operations on them.

We assign names to scalars (objects) using the operator `<-` (Shortcuts: `Alt` + `-`in Windows; `Option` + `-` inn macOS).

```{r}
scal_num <- 1
scal_chr <- "a"
scal_str <- "word"
scal_log <- TRUE # logical/Boolean
```

We can access (look into) the object by typing its name and sending the line to the console.

```{r}
scal_num
```

Having create scalar objects and knowing what it is them, we can continue manipulating them.
For simplicity, we use the object to run some arithmetic expressions on them.

```{r}
scal_num + 1
scal_num + scal_num
scal_num + scal_num / 2
(scal_num + scal_num) / 2
```

The above examples gives us an idea of what `R` is doing when it is supplied with an object that we previously defined: 
It takes the data that is stored inside them and runs the operation on them. 
Storing data in objects becomes particularly helpful if the data is not just a scalar.

Before we turn to more complex object types, let's briefly consider how we can overwrite existing objects or create new objects by running operation on existing ones.

```{r eval=FALSE}
scal_num
scal_num <- scal_num + 1  # overwriting
scal_num
scal_num2 <- scal_num + 1 # creating
scal_num2
```
Occasionally, we will write code that represents an invalid operation.
In these cases, R will return an error message.
E.g., we can multiple numerical values, but not characters. 

```{r eval=FALSE}
scal_chr * 4
```

[Error in scal_chr \* 4 : non-numeric argument to binary operator]{style="color:red;"}

If `R` returns an error, the only thing we can do about it is inspect the code and find the error.
In most cases, simply re-running the command that triggered an error message will not solve the problem. 

#### Vectors

When working in `R`, vectors are among the most common types of data structure that we'll encounter. 
A vector is an ordered collection of single values that all belong to the same data type (e.g., numeric or character or logical). 
We can produce a vector object using the known `<-` assignment operator and the `c()` command, which "chains" the values into a vector.

```{r}
x <- c(1, 2, 3, 4) # create a vector object x
x
```

One of `R`'s prime features is it's "vectorized" nature. 
This means that `R` performs the same operation on an entire vector --- i.e., on each value within a vector --- at once. 

```{r}
x*2
```

When manipulating vectors in `R`, the position of each value within the vector is taken into account. 
Specifically, operations between vectors are performed in a way that applies a given operation to elements that occupy the same position in their vectors. 
To illustrate this, let us take the example of multiplying two vectors `x` and `y` of the same length (both contain 4 individual values). 
The multiplication operation will be applied to the first value of x and the first element of y, the second value of x and the second value of y, and so on.
The resulting output will be a vector of the same length as x and y.

```{r}
x <- c(1, 2, 3, 4) # vector x
y <- c(1, 2, 3, 4) # vector y
x*y
```

This vectorization is a bit more tricky if the vectors don't have the same length.
Consider the following example where the `x` from above is multiplied with a shorter vector `z`: 

```{r}
z <- c(1,2) # vector z
x*z
```

What is going on here? 
When two vectors don't have the same length, the shorter vector is implicitly repeated until it has the same length as the longer vector.
In the above case, `z` is implicitly turned from `c(1,2)` into `c(1,2,1,2)`, i.e., it is replicated to obtain the length 4.
Then, as previously, the operations are performed element wise.
We can check this by explicitly replicating the vector `z`. 

```{r}
z <- rep(z, 2) # replicates and overwrite z
z
x*z
```

There is a lot more to learn and do with vectors.
However, for now we turn to a bit more complex data structure, one which entails multiple vectors.

#### Data Frames

Being a collection of values, vectors are ideally suited to represent variables in a data frame. 
Data frames are a data structures we will encounter in virtually every data analysis project.
[According to Hadley Wickham](https://r4ds.had.co.nz/tidy-data.html), every messy data set is messy in its own way, but tidy data sets are all alike. 
Specifically, tidy data sets follow a small set of simple rules:

1.  Each variable must have its own column.
2.  Each observation must have its own row.
3.  Each value must have its own cell.

To put these rules in action, consider the following example, where we first create 3 individual vectors, `x`, `y`, `z`, and then represent them as different variables in a data frame object `dat`.
For the latter operation, we use the function `data.frame()`.

```{r}
x <- c(1, 2, 3)
y <- c(4, 5, 6)
z <- c(7, 8, 9)
dat <- data.frame(x, y, z)
dat
```

Not all data sets in the wild will look this neat right from the start and usually they will be a lot bigger.
However, irrespective of its initial form and size, in most data analysis projects you want to bring the data into this data frame format before you start analyzing it.

One advantage becomes immediately clear: Row numbers indicate positions within the vectors that represent variables. 
This applies to all variables (columns) in the data set without exception.
To grasp the full advantage, assume that each row represents a single unit of analysis (e.g., countries, companies, individuals).
This is what rows (should) usually do. 
Now we can see that each value on each variable belongs to exactly one analysis unit, indicated by the row number.
To make this clear, let's add an indicator variable `ID` to `dat`.

```{r}
ID <- c("A", "B", "C")
dat <- data.frame(ID, dat)
dat
```

Now we have three different analysis units, `A`, `B`, `C`, which could stand for individual countries, companies, people or the like, each of which has one value on each variable. 
In many --- although not all --- cases we want to operate on variables across all analysis units (e.g., computing a variable mean, recoding variable values). 
In this case, we can make perfect use of `R`'s vectorized nature and simply apply the same operation on a variable to all rows at once. 
You'll soon appreciate both the format and the feature.

As data frames are a very common data structure (object type), we need to learn a set of commands that help us to manipulate them and obtain the information we want. 
We will now briefly go over some basic commands. 
Throughout the course, we'll learn about a set of functions from the `tidyverse` package that makes writing code and working with data frames particularly easy, even if the manipulations are rather complex.

As with vectors, we can apply the same operation to an entire data frame.
Consider the following example, where each cell entry is multiplied by 2.

```{r}
x <- c(1, 2, 3)
y <- c(4, 5, 6)
z <- c(7, 8, 9)
dat <- data.frame(x, y, z)
dat*2
```

To multiply each single value (cell entry), `R` operates element-wise, starting from the left and traversing the columns one by one from top to bottom.
This element-wise operation is implied by `R`'s vectorized nature:
Implicitly, `R` represents all cell entries in a single vector and repeats the scalar 2 as often as there are cell entries. 
Rarely, this is what we need and at times this behavior causes confusion.

Instead, we usually want to apply operations to specific variables or cells in a data frame. 
There are multiple ways to retrieve a variable from a data frame.
In the following, you can see at least 3 ways that come with the standard installation of `R`.

```{r}
dat$x # dollar notation with variable name
dat[, 1] # matrix notation with column number
dat[, "x"] # matrix notation with variable name
```

In the *matrix notation*, values prior the comma represent rows and values after the comma represent columns.
The matrix notation has two advantages over the dollar notation: 
First, we can refer to columns both by column number and variable name. 
Second, we can also obtain multiple variables (columns) at once or specific cell entries.

```{r}
# multiple columns
dat[, c(1,2)]
dat[, c("x","y")]

# specific cell entries
dat[1,1] # cell entry row 1 and column 1
dat[1, "x"]
```

Knowing how to retrieve variables from a data frame, we can now apply operations on them as before. 
The basic principles of vectorized operations remain the same.
Consider the following 3 examples, where we multiply the variable `x` (column 1) with the scalar 2 and or the vector `a`.

```{r}
dat[, 1] * 2
a <- c(1,2,3)
dat[, 1] * a 
dat$x * a
```

Importantly, the above code doesn't change the object `dat` but only returns the output of the operation.
To store the outputs in `dat`, we use the assignment operator `<-` and point it to the position in the `dat` where we want to store the outputs.
For instance, we can create a new column `v` and attach it to the existing data frame:

```{r}
dat[, "v"] <- dat[, 1] * a 
dat
```

Or we can overwrite an existing column:

```{r}
# overriding
dat[, 4] <- dat[, 4] / a
dat
```

#### Functions

Simple arithmetic operations are by no means the only possible operations in `R`.
You already come across other operations in the form of *functions* such as `data.frame()` or `rep()`.
Moreover, multiple operations can be combined and chained to achieve more complex computations.
However, irrespective of the exact computation, the more often you need it, the less inclined you should be to write the code from scratch over and over and over again. 
Copying and pasting the code can circumvent this problems, but it comes with its own pitfalls. 
As a general rule of thumb for programming --- statistical or otherwise --- you want to reduce code duplications.  

One way to reduce duplications in your `R` code is by working with functions.
Functions reduce code duplications by encapsulating a particular set of commands that perform a computation and only extracting the parts out that are changing between runs. 
To illustrate, consider you want to run the same set of operations on multiple variables.
Although the only thing that changes between repeated runs is the variable, you always need to send the entire code to the console, which can easily make up several lines.
Encapsulating a set of operations in a function allows you to reduce many lines to just a function name and some arguments (the independent, changing parts) which together usually make up no more than a line.
This results in code and scripts that are much cleaner, easier to read, and ultimately less prone to errors. 

In the following, we briefly consider how functions are build. 
A function generally consists of three parts:

1.  A function name.
2.  Objects and other arguments that are the inputs to the function (independent, changing parts).
3.  The code body `{}` that specifies the code and turns inputs into outputs.

To illustrate, consider the following code with which we define a function `summing()` that sums up all values of a vector:

```{r}
summing <- # function name
  function(x){ # inputs 
    
    # body 
    total <- 0
    for (i in 1:length(x)) {
    total <- total + x[i]
  }
  return(total)
    
}
```

At this point, we don't need to understand all particularities of the code. 
The main idea is that we have now created a function `summing()` that sums up all values within numeric vectors. 
Specifically, the function `summing()` takes as input a vector substitutes the placeholder `x` in the above code body with this vector, and then executes the code.
To see the function in action, we just need to write the name of the function and place the vector of interest in the input bracket. 

```{r}
x <- c(1,2,3)
summing(x)
```

Of course, computing the sum of a variable/vector is a common operation and there is already a function in place for it:

```{r}
sum(x)
```

Because many sets of operations are fairly common and useful to different projects, others might have already written a function for this operation. 
Some of these functions might come with the initial `R` installation such as `data.frame()`, `rep()`, and `sum`, while others are obtained by installing additional *packages* that are distributed and freely available online. 
Either way, the important takeaway is that before you start repeatedly writing endless lines of code or racking your brain to come up with a function, you should search online to see if there is already a function that does what you need.

One last thing about `R` code and functions: 
You can combine the operations of multiple functions by placing functions into one another. 
The way it works is by reading the `R` code from the inside to the outside. 
More specifically, a function returns an output.
The output of the inner (or enclosed) function is then used as input of the outer function.
To illustrate consider the following example that combines the `sum()` function and the `abs()` function, which returns the non-negative absolute value of scalars. 
First, we do the operation one by one by saving the output of `sum()` in a new object, which is then used as input to `abs()`. 
Thereafter, we do it all at once.

```{r}
x <- c(-1, -2, -3)
sum_x <- sum(x)
sum_x
abs(sum_x)
abs(sum(x))
```
#### Packages

To conclude this primer on `R`, let's briefly elaborate a bit more on the idea of *packages*.
`R` packages may entail functions, data, and documentation that are not provided with the standard installation of `R`. 
`R` packages are created and maintained by a community of developers and users who share their work with others.
These packages can be downloaded from the internet and installed in `R` using the function `install.packages()` function. 
Once installed, the functions and data in the package can be made available in `R` by using the function `library()`. 

In the following, we install the `tidyverse` package, which itself contains a collection of packages that offer a rich and powerful set of functions for working with data frames.

```{r eval = FALSE}
install.packages("tidyverse")
library("tidyverse")
```

Besides the `tidyverse`, there are thousands of other `R` packages available for a wide range of tasks, from data manipulation and visualization to statistical modeling and machine learning. 
Using packages will save you a lot of time and effort, allowing you to focus on what you are here for: data analysis.
Now that we have learned some basics of `R`, we will continue with learning Git and GitHub.

# Hello `Git`

-   Check if Git is already installed.
-   Open a shell/terminal on your machine and type:

``` bash
git --version
```

-   If the command returns something along the lines `git version ...`, you are fine. If the command returns `git: command not found`, Git is not installed yet. Install Git from the [browser](https://git-scm.com/downloads) and repeat the above procedure.

-   Introduce yourself to Git with a user name and the E-mail address you (will) use for the GitHub account.

``` bash
git config --global user.name 'YOUR USERNAME'
git config --global user.email 'YOUR EMAIL ADDRESS'
```

-   Check if everything works:

``` bash
git config --global --list
```

-   Somewhere in the output, you should find a line that entails your username and a line that entails the e-mail address.
-   Restart your machine.

# Hello GitHub

-   If not done yet, go to [GitHub](https://github.com) and create an account with the E-Mail address you introduced to Git before.

## Personal Access Token

-   To allow Git to communicate with GitHub via the HTTPS protocol, we need to generate and store a [personal access token (PAT)](https://github.com/settings/tokens)
-   Use the following R shortcut that comes with a pre-selected scope.

```{r eval = F}
install.packages("usethis")
usethis::create_github_token()
```

-   Give the PAT a clear name (e.g., my-private-machine), "Generate token", copy the PAT to the clipboard and paste it somewhere for short term storage (also, don't close the window yet).
-   Run the following lines of code to store the PAT by pasting it into the console:

```{r eval = F}
install.packages("gitcreds")
gitcreds::gitcreds_set()
```

## Create and Clone a Repository

-   Go to GitHub and create a [new repository](https://github.com/new).
-   Add a description and click "Add README file".
-   Create a repository.
-   Clone the repository to your computer via the green "\<\> Code" button. Click "HTTPS" and copy the address.
-   Go to R and open a new project with version control (Copy the remote address).

## GitHub Fundamentals

### Commit, Push, Pull

-   In the following, you want to exercise some commands fundamental to the work with `Git`: `pull`, `push`, `commit`.

-   `commit` allows you to save the latest changes in your repository (e.g., if you added some new lines of code)

-   `pull` and `push` sync the local repository on your machine and the remote repository on GitHub. With `pull` you sync changes that were first made in the remote repository; with `push`, you snyc changes made in the local repository.

-   It is a good practice to first pull from the remote repository before you push back to GitHub. To practice, do some changes on GitHub, commit, and pull them to the local repository. Then do some changes in the local repository, commit, and push them. Repeat to gain some practice.

## Branching

-   With `Git`, you can create branches besides the main branch. Such feature branches allow you to let the main branch as it is and test new things on them. Later, you can merge changes on the feature branch into the main branch.

-   You create a branch from the terminal with `bash git branch "branch-name"` and then checkout to the branch with `bash git checkout "branch-name"`.

-   Once you have done some work on the feature branch and commited it, you can checkout to the main branch again and merge the changes.

``` bash
git checkout main
git merge branch-name
```

## Pull requests.

\[...\]

![Copyright Jenny Bryan](git_primer_files/remote-set-up.png){fig-align="center" width="408"}

-   Go to the original GitHub repo (source repo) you want to commit changes to and create a fork (repository) to your own account:

![](git_primer_files/fork.PNG){fig-align="center" width="1056"}

-   Clone the fork to your local machine by creating a new R project.

-   Using the command line, check the remote repository of your project (`origin` should be your fork).

``` bash
git remote -v
```

-   Before you start suggesting changes to the source repository, you want to make sure to commit to the most recent version of the source. Therefore, you have to set the source repository as another remote repository. As a convention the source repository is called `upstream`.

``` bash
git remote upstream url-of-original-repository.
```

-   Check the remote repositories again.

-   Now you also want to see the source repository as `source`.

`git remote -v`

-   One important thing to notice is that you are not allowed to push directly to the source from your fork, but you are able to pull directly from the source into the fork. The only thing you can do is requesting to commit changes to the source. Therefore, you proceed as follows:

1.  In your local fork, create a branch with a meaningful name
2.  Make changes on that branch and commit them.
3.  Push the changes to a new remote branch in your fork (`origin`).

``` bash
git push origin branch-name
```

4.  Visit your fork on GitHub. You will find a panel that suggests making a pull request.

![](git_primer_files/pull-request.PNG){fig-align="center"}

5.  Open the pull request, add a comment and create it. The owner of the source will be notified and can review the request. Done.

##### How to continue

-   If the owner accepts your changes, they will be committed to the source and you will appear as contributor. In this case, you can either delete the fork entirely or leave it to come back at a later point.

-   When you come back at a later point, you probably want to pick up with the most recent version of the source. To obtain the most recent changes and get your fork in sync, you have 2 options.

A)  

    1.  Sync remote fork in GitHub, pull from remote fork into local repo

B)  

    1.  Pull from source into local repo, push to remote fork

-   You are now set to make another pull request. For the new pull request, you should create a new branch and not take the old one. Old branches can be deleted using the command line:

``` bash
git branch -d branch-name #local
git push origin -d branch-name #remote
```

#### Issues

On GitHub, you can also create issues to track bugs, request features, point to other problems or list remaining to dos.

#### Opening an issue

-   In a Github repo, go to the issues page and click on "New Issue"

![](git_primer_files/issues.PNG){fig-align="center"}

-   Give the issue a name and, optionally, add a comment for more context.

#### Closing an issue

There are multiple options to close an issue.

-   If the issue is resolved, you can manually close the issue on GitHub via the issue page.

-   In your local repo, make a commit and and close the issue with a commit message. The commit message must entail the following string `KEYWORD ISSUE`. The issues is indicated by a `#` and a number. Keywords that work are: `close`, `closes`, `closed`, `fix`, `fixes`, `fixed`, `resolve`, `resolves`, `resolved`. E.g., close an Issue #5, you can write the following commit message

``` bash
define new variable; closes #5
```

-   If you push the commit to GitHub, the issue will automatically be closed.
-   You can also link pull requests to existing issues. Just add the string `KEYWORD ISSUE` to the commit of the pull request. If the pull request is approved and merged, the issue will get closed.

# Resources

[Happy Git](Happy%20Git%20and%20GitHub%20for%20the%20useR)
